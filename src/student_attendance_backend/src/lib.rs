#[macro_use]
extern crate serde;
use candid::{Decode, Encode};
use ic_cdk::api::time;
use ic_stable_structures::memory_manager::{MemoryId,MemoryManager,VirtualMemory};
use ic_stable_structures::{BoundedStorable,Cell,DefaultMemoryImpl,StableBTreeMap,Storable};
use std::{borrow::Cow, cell::RefCell};

//store canister state and generate a unique id for each lecturer
type Memory= VirtualMemory<DefaultMemoryImpl>;
type IdCell=Cell<u64, Memory>;

//Defining lectures structure
#[derive(candid::CandidType, Clone,Serialize,Deserialize,Default)]
struct Lecture {
    id: u64,
    unit_code: String,
    unit_name: String,
    lecture_hall_no: u64,
    lecturer_id: String,
    lecturer_name: String,
    start_time: u64,
    stop_time: Option<u64>,
    number_of_full_attend: u64,
    number_of_partial_attendance: u64,

}

//implementing for storage stability in struct lecturer it is a trait
impl Storable for Lecture {
    fn to_bytes(&self) -> std::borrow::Cow<[u8]> {
        Cow::Owned(Encode!(self).unwrap())
    }

    fn from_bytes(bytes: std::borrow:: Cow<[u8]>) -> Self {
        Decode!(bytes.as_ref(),Self).unwrap()
    }
}

//another implemented trait for struct that is stored in a stable struct
impl BoundedStorable for Lecture {
    const MAX_SIZE: u32 = 1024;
    const IS_FIXED_SIZE: bool = false;
}


//Threads tto hold state for the canister to allow sharing of data,use of refcell for anywhere access

thread_local! {
    //holds canister virtual memory enabling access from any part of code
    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> = RefCell::new(
      MemoryManager::init(DefaultMemoryImpl::default())
    );

    //holds canister id allowing access from anywhere
    static ID_COUNTER: RefCell<IdCell> = RefCell::new(
        IdCell::init(MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(0))),0)
        .expect("Cannot create a counter")
    );

    //hold canister storage enabling access from anywhere
    static STORAGE: RefCell<StableBTreeMap<u64,Lecture,Memory>> =
    RefCell::new (StableBTreeMap::init(
        MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(1)))
    ));
}

//payload defines the data that will be used in the canister that is not autogenerated but filled by user
#[derive(candid::CandidType,Serialize,Deserialize,Default)]
struct LecturePayload{
    unit_code: String,
    unit_name: String,
    lecture_hall_no: u64,
    lecturer_id: String,
    lecturer_name: String,
    number_of_full_attend: u64,
    number_of_partial_attendance: u64
}

//access the lecture information and details about it using the lecture id and its evaluated here before an output
#[ic_cdk::query]
fn get_lecture(id: u64) ->Result<Lecture, Error> {
    match _get_lecture(&id) {
        Some(lecture)=> Ok(lecture),
        None => Err(Error::NotFound{
            msg: format!("A lecture with id={:?} does not exist", id)
        }),
    }
}

//helper function for access of lectures from the storage
fn _get_lecture(id: &u64) -> Option<Lecture> {
    STORAGE.with(|s|s.borrow().get(id))
}

//function used to create lectures in the canister storage
#[ic_cdk::update]
fn create_lecture(lecture: LecturePayload) -> Option<Lecture>{
    let id =ID_COUNTER
        .with(|counter|{
            let current_value= *counter.borrow().get();
            counter.borrow_mut().set(current_value + 1)
        })
        .expect("Cannot increment id counter");
    let lecture = Lecture {
        id,
        unit_code: lecture.unit_code,
        unit_name: lecture.unit_name,
        lecture_hall_no: lecture.lecture_hall_no,
        lecturer_id: lecture.lecturer_id,
        lecturer_name: lecture.lecturer_name,
        start_time: time(),
        stop_time: None,
        number_of_full_attend: lecture.number_of_full_attend,
        number_of_partial_attendance: lecture.number_of_partial_attendance,
    };

    do_insert(&lecture);
    Some(lecture)
}

//helper function to insert our lectures in storage with the id
fn do_insert (lecture: &Lecture) {
    STORAGE.with(|service| service.borrow_mut().insert(lecture.id,lecture.clone()));
}


//update lectures end time and the number of students who partially attended and full attendance
#[ic_cdk::update]
fn finalize_lecture(id: u64,payload: LecturePayload) -> Result<Lecture, Error> {
    match STORAGE.with(|service| service.borrow().get(&id)) {
        Some(mut lecture) =>{
            lecture.number_of_full_attend=payload.number_of_full_attend;
            lecture.number_of_partial_attendance=payload.number_of_partial_attendance;
            lecture.stop_time= Some(time());
            do_insert(&lecture);
            Ok(lecture)
        }
        None => Err(Error::NotFound {
            msg: format!(
                "couldn't update lecture with id {:?} contact administration with lecture number for assistance",
                id
            ),
        })
    }
}

//delete a lecture in case of keying in wrong details available within 24 hours of lecture creation

#[ic_cdk::update]

fn delete_lecture(id: u64)-> Result<Lecture,Error>  {
    match STORAGE.with(|service| service.borrow_mut().remove(&id)){
        Some (lecture) => Ok(lecture),
        None=> Err(Error::NotFound{
            msg: format!(
                "couldn't delete lecture with id={:?}.Lecture not found",
                id
            ),
        }),
    }

}

//enum for errors showing possible errors
#[derive(candid::CandidType,Deserialize,Serialize)]
enum Error {
    NotFound {msg: String},
}

//candid file generator
ic_cdk::export_candid!();